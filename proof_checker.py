"""
Given a proof file generated by the SAT solver, will verify the proof's correctness.

The solver should print out the proof in a file; where the first line should being with “v <# of clauses>” 
where <# of clauses> specify the number of clauses in your resolution proof. 
Then the next <# of clauses> should list down all the clauses that are used in resolution proof. 
An empty clause is also a clause, you can use the symbol -1 to specify empty clause. 
Note that this ordering also assigns unique id to every clause.
Following listing of all the clauses, you should list down the actual proof in the following format. 
Every line should first list the id two clauses used in resolution and then the clause that was generated. 
(E.g., “1 2 3” would represent clause 1 and clause 2 were used in resolution and clause 3 was produced). 
The last line should end with empty clause being generated (If it is an UNSAT formula).
"""
import os

path = "proof.txt"

def main():
    with open(os.path.join(os.getcwd(), path)) as f:
        proof = f.read()
    
    lines = proof.strip().split("\n")
    start, clauses = parse_clauses(lines)
    check_proof(lines, start, clauses)

    print("Proof verified")

def parse_clauses(lines):
    tokens = lines[0].strip().split()
    n_clauses = int(tokens[1])
    clauses = []

    for line in lines[1: 1 + n_clauses]:
        tokens = line.strip().split()
        
        try:
            clause = set()

            for token in tokens:                
                literal = int(token)
                clause.add(literal) # variable is an integer, with a negative integer denoting a negation of the variable

        except ValueError as e:
            print("Error, variable should be a nonzero number.")
            
        clauses.append(frozenset(clause))

    return 1 + n_clauses, clauses

def check_proof(lines, start, clauses):
    for line in lines[start:]:
        tokens = line.strip().split()
        clause_indexes = [int(token) for token in tokens]
        check_resolution(clause_indexes, clauses)

def check_resolution(clause_indexes, clauses):
    # ensures that the newly derived clause comes after the current clauses in derivation order
    assert clause_indexes[2] > clause_indexes[0] and clause_indexes[2] > clause_indexes[1]

    resolution_clauses = [clauses[clause_index] for clause_index in clause_indexes]
    pivot = get_pivot(resolution_clauses[0], resolution_clauses[1])
    resolved_clause = resolution(resolution_clauses[0], resolution_clauses[1], pivot)
    
    # ensures the clause3 is the resolved clause of clause1 and clause2
    assert resolution_clauses[2] == resolved_clause

def get_pivot(clause1, clause2):
    for literal in clause1:
        if -literal in clause2:
            return literal

def resolution(clause1, clause2, pivot):
        """
        Performs resolution on 2 clauses with a given pivot
            :param clause1: Clause containing pivot.
            :param clause2: Clause containing negation of pivot.
            :param pivot: Literal in clause1 whose negation is in clause2.
            :returns: Resolved clause containing all literals in both clauses except pivot and its negation.
        """
        resolved_clause = { literal for literal in clause1 if literal != pivot }
        resolved_clause |= { literal for literal in clause2 if literal != -pivot }

        return frozenset(resolved_clause)

if __name__ == "__main__":
    main()